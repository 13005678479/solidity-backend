Solidity中的变量类型

1、值类型(Value Type)：包括布尔型，整数型等等，这类变量赋值时候直接传递数值。
2、引用类型(Reference Type)：包括数组和结构体，这类变量占空间大，赋值时候直接传递地址（类似指针）。
3、映射类型(Mapping Type): Solidity中存储键值对的数据结构，可以理解为哈希表

Solidity语言的函数非常灵活

function <function name>([parameter types[, ...]]) {internal|external|public|private} [pure|view|payable] [virtual|override] [<modifiers>]
[returns (<return types>)]{ <function body> }

function：声明函数时的固定用法。要编写函数，就需要以 function 关键字开头。
<function name>：函数名。
([parameter types[, ...]])：圆括号内写入函数的参数，即输入到函数的变量类型和名称。
{internal|external|public|private}：函数可见性说明符，共有4种。
public：内部和外部均可见。
private：只能从本合约内部访问，继承的合约也不能使用。
external：只能从合约外部访问（但内部可以通过 this.f() 来调用，f是函数名）。
internal: 只能从合约内部访问，继承的合约可以用。
[pure|view|payable]：决定函数权限/功能的关键字。payable（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入 ETH。pure 和 view 的介绍见下一节。
[virtual|override]: 方法是否可以被重写，或者是否是重写方法。virtual用在父合约上，标识的方法可以被子合约重写。override用在子合约上，表名方法重写了父合约的方法。
<modifiers>: 自定义的修饰器，可以有0个或多个修饰器。
[returns ()]：函数返回的变量类型和名称。
<function body>: 函数体。

Solidity 中与函数输出相关的有两个关键字：return和returns。它们的区别在于：
returns：跟在函数名后面，用于声明返回的变量类型及变量名。
return：用于函数主体中，返回指定的变量。

// 返回多个变量
function returnMultiple() public pure returns(uint256, bool, uint256[3] memory){
    return(1, true, [uint256(1),2,5]);
}

Solidity中变量按作用域划分有三种，分别是状态变量（state variable），局部变量（local variable）和全局变量(global variable)

Solidity中两个关键字，constant（常量）和immutable（不变量），让不应该变的变量保持不变。这样的做法能在节省gas的同时提升合约的安全性

继承是面向对象编程很重要的组成部分，可以显著减少重复代码。如果把合约看作是对象的话，Solidity也是面向对象的编程，也支持继承
规则
virtual: 父合约中的函数，如果希望子合约重写，需要加上virtual关键字。
override：子合约重写了父合约中的函数，需要加上override关键字。

接口类似于抽象合约，但它不实现任何功能。接口的规则

不能包含状态变量
不能包含构造函数
不能继承除接口外的其他合约
所有函数都必须是external且不能有函数体
继承接口的非抽象合约必须实现接口定义的所有功能

另外，接口与合约ABI（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的ABI，利用abi-to-sol工具，也可以将ABI json文件转换为接口sol文件

IERC721包含3个事件，其中Transfer和Approval事件在ERC20中也有。

Transfer事件：在转账时被释放，记录代币的发出地址from，接收地址to和tokenId。
Approval事件：在授权时被释放，记录授权地址owner，被授权地址approved和tokenId。
ApprovalForAll事件：在批量授权时被释放，记录批量授权的发出地址owner，被授权地址operator和授权与否的approved。

IERC721函数

balanceOf：返回某地址的NFT持有量balance。
ownerOf：返回某tokenId的主人owner。
transferFrom：普通转账，参数为转出地址from，接收地址to和tokenId。
safeTransferFrom：安全转账（如果接收方是合约地址，会要求实现ERC721Receiver接口）。参数为转出地址from，接收地址to和tokenId。
approve：授权另一个地址使用你的NFT。参数为被授权地址approve和tokenId。
getApproved：查询tokenId被批准给了哪个地址。
setApprovalForAll：将自己持有的该系列NFT批量授权给某个地址operator。
isApprovedForAll：查询某地址的NFT是否批量授权给了另一个operator地址。
safeTransferFrom：安全转账的重载函数，参数里面包含了data。

error方法gas最少，其次是assert，require方法消耗gas最多！因此，error既可以告知用户抛出异常的原因，又能省gas，大家要多用

Solidity中允许函数进行重载（overloading），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，Solidity不允许修饰器（modifier）重载。

库合约是一种特殊的合约，为了提升Solidity代码的复用性和减少gas而存在

Solidity支持两种特殊的回调函数，receive()和fallback()

receive()函数是在合约收到ETH转账时被调用的函数。一个合约最多有一个receive()函数，声明方式与一般函数不一样，不需要function关键字：receive() external payable { ... }。
receive()函数不能有任何的参数，不能返回任何值，必须包含external和payable。

fallback()函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约proxy contract。
fallback()声明时不需要function关键字，必须由external修饰，一般也会用payable修饰，用于接收ETH:fallback() external payable { ... }。

call不是调用合约的推荐方法，因为不安全

什么情况下会用到delegatecall

目前delegatecall主要有两个应用场景：

代理合约（Proxy Contract）：将智能合约的存储合约和逻辑合约分开：代理合约（Proxy Contract）存储所有相关的变量，并且保存逻辑合约的地址；
所有函数存在逻辑合约（Logic Contract）里，通过delegatecall执行。当升级时，只需要将代理合约指向新的逻辑合约即可。
EIP-2535 Diamonds（钻石）：钻石是一个支持构

在以太坊链上，用户（外部账户，EOA）可以创建智能合约，智能合约同样也可以创建新的智能合约。
去中心化交易所uniswap就是利用工厂合约（PairFactory）创建了无数个币对合约（Pair）

selfdestruct命令可以用来删除智能合约，并将该合约剩余ETH转到指定地址

selfdestruct是智能合约的紧急按钮，销毁合约并将剩余ETH转移到指定账户。
当著名的The DAO攻击发生时，以太坊的创始人们一定后悔过没有在合约里加入selfdestruct来停止黑客的攻击吧

ABI (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。
数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。

以太坊中，数据必须编码成字节码才能和智能合约交互

哈希函数（hash function）是一个密码学概念，它可以将任意长度的消息转换为一个固定长度的值，这个值也称作哈希（hash）
一个好的哈希函数应该具有以下几个特点：
单向性：从输入的消息到它的哈希的正向运算简单且唯一确定，而反过来非常难，只能靠暴力枚举。
灵敏性：输入的消息改变一点对它的哈希改变很大。
高效性：从输入的消息到哈希的运算高效。
均一性：每个哈希值被取到的概率应该基本相等。
抗碰撞性：
弱抗碰撞性：给定一个消息x，找到另一个消息x'，使得hash(x) = hash(x')是困难的。
强抗碰撞性：找到任意x和x'，使得hash(x) = hash(x')是困难的。

ERC20是以太坊上的代币标准，来自2015年11月V神参与的EIP20

空投是币圈中一种营销策略，项目方将代币免费发放给特定用户群体。为了拿到空投资格，用户通常需要完成一些简单的任务，如测试产品、分享新闻、介绍朋友等。

EIP全称 Ethereum Improvement Proposals(以太坊改进建议), 是以太坊开发者社区提出的改进建议, 是一系列以编号排定的文件, 类似互联网上IETF的RFC。

EIP可以是 Ethereum 生态中任意领域的改进, 比如新特性、ERC、协议改进、编程工具等等。
ERC全称 Ethereum Request For Comment (以太坊意见征求稿), 用以记录以太坊上应用级的各种开发标准和协议。
如典型的Token标准(ERC20, ERC721)、名字注册(ERC26, ERC13), URI范式(ERC67), Library/Package格式(EIP82), 钱包格式(EIP75,EIP85)。
ERC协议标准是影响以太坊发展的重要因素, 像ERC20, ERC223, ERC721, ERC777等, 都是对以太坊生态产生了很大影响。

所以最终结论：EIP包含ERC。

Merkle Tree，也叫默克尔树或哈希树，是区块链的底层加密技术，被比特币和以太坊区块链广泛采用。Merkle Tree是一种自下而上构建的加密树，每个叶子是对应数据的哈希，而每个非叶子为它的2个子节点的哈希

OpenSea是以太坊上最大的NFT交易平台，总交易总量达到了$300亿。OpenSea在交易中抽成2.5%，因此它通过用户交易至少获利了$7.5亿。另外，它的运作并不去中心化，且不准备发币补偿用户

以太坊EIP1155提出了一个多代币标准ERC1155，允许一个合约包含多个同质化和非同质化代币

WETH (Wrapped ETH)是ETH的带包装版本。我们常见的WETH，WBTC，WBNB，都是带包装的原生代币

分账就是按照一定比例分钱财。在现实中，经常会有“分赃不均”的事情发生；而在区块链的世界里，Code is Law，我们可以事先把每个人应分的比例写在智能合约中，获得收入后，再由智能合约来进行分账。

线性释放指的是代币在归属期内匀速释放

代币锁(Token Locker)是一种简单的时间锁合约，它可以把合约中的代币锁仓一段时间，受益人在锁仓期满后可以取走代币。代币锁一般是用来锁仓流动性提供者LP代币的。

时间锁主要有三个功能：

创建交易，并加入到时间锁队列。
在交易的锁定期满后，执行交易。
后悔了，取消时间锁队列中的某些交易。

代理合约利用delegatecall将函数调用委托给了另一个逻辑合约，使得数据和逻辑分别由不同合约负责。并且，它利用内联汇编黑魔法，让没有返回值的回调函数也可以返回数据

透明代理的逻辑非常简单：管理员可能会因为“函数选择器冲突”，在调用逻辑合约的函数时，误调用代理合约的可升级函数。那么限制管理员的权限，不让他调用任何逻辑合约的函数，就能解决冲突：

多签钱包是一种电子钱包，特点是交易被多个私钥持有者（多签人）授权后才能执行：例如钱包由3个多签人管理，每笔交易需要至少2人签名授权。

ERC20Permit，一个 ERC20 代币标准的拓展，支持用户使用链下签名进行授权操作，改善了用户体验，被很多项目采用。但同时，它也带来了更大的风险，一个签名就能将你的资产卷走

跨链桥是一种区块链协议，它允许在两个或多个区块链之间移动数字资产和信息。
例如，一个在以太坊主网上运行的ERC20代币，可以通过跨链桥转移到其他兼容以太坊的侧链或独立链。

跨链桥，它允许在两个或多个区块链之间移动数字资产和信息，方便用户在多链操作资产。
同时，它也有很大的风险，近两年针对跨链桥的攻击已造成超过20亿美元的用户资产损失

MultiCall（多重调用）合约的设计能让我们在一次交易中执行多个函数调用

恒定乘积自动做市商（Constant Product Automated Market Maker, CPAMM），它是去中心化交易所的核心机制，被Uniswap，PancakeSwap等一系列DEX采用

自动做市商（Automated Market Maker，简称 AMM）是一种算法，或者说是一种在区块链上运行的智能合约，它允许数字资产之间的去中心化交易。
AMM 的引入开创了一种全新的交易方式，无需传统的买家和卖家进行订单匹配，而是通过一种预设的数学公式（比如，常数乘积公式）创建一个流动性池，使得用户可以随时进行交易。

闪电贷，实现基于Uniswap V2，Uniswap V3，和AAVE V3的闪电贷合约，并使用Foundry进行测试

不仅仅ETH转账会触发重入攻击，ERC721和ERC1155的safeTransfer()和safeTransferFrom()安全转账函数，还有ERC777的callback函数，都可能会引发重入攻击

函数选择器很容易被碰撞，即使改变参数类型，依然能构造出具有相同选择器的函数。

管理好合约函数的权限，确保拥有特殊权限的合约的函数不能被用户调用。

智能合约中的权限管理定义了不同角色在应用中的权限

整型溢出漏洞（Arithmetic Over/Under Flows）。这是一个比较经典的漏洞，Solidity 0.8版本后内置了Safemath库，因此很少发生

数字签名可以用于识别数据签名者和验证数据完整性。发送交易时，用户使用私钥签名交易，使得其他人可以验证交易是由相应账户发出的。智能合约也能利用 ECDSA 算法验证用户将在链下创建的签名，然后执行铸造或转账等逻辑

签名重放漏洞三个预防方法
将使用过的签名记录下来，防止二次使用。
将 nonce 和 chainid 包含到签名消息中。
对于由用户输入signature的场景，需要检验signature的长度，确保其长度为65bytes，否则也会产生签名重放问题。

坏随机数漏洞
使用预言机项目提供的链下随机数

在 Web2 中，拒绝服务攻击（DoS）是指通过向服务器发送大量垃圾信息或干扰信息的方式，导致服务器无法向正常用户提供服务的现象。
而在 Web3，它指的是利用漏洞使得智能合约无法正常提供服务。

链上抢跑指的是搜索者或矿工通过调高gas或其他方法将自己的交易安插在其他交易之前，来攫取价值
抢先交易是以太坊等公链上普遍存在的问题。我们没法消除它，但是可以通过减少交易顺序或时间的重要性，减少被抢先交易的收益：
使用预提交方案(commit-reveal scheme)。
使用暗池，用户发出的交易将不进入公开的mempool，而是直接到矿工手里。例如 flashbots 和 TaiChi。
在调用参数中加上保护性参数，如滑点保护，从而减少抢跑者的潜在收益。

智能合约中的tx.origin钓鱼攻击，目前有两种方法可以预防它：
一种是使用msg.sender代替tx.origin；另一种是同时检验tx.origin == msg.sender。
推荐使用第一种方法预防，因为后者会拒绝所有来自其他合约的调用。

未检查低级调用的漏洞
以太坊的低级调用（call, delegatecall, staticcall, send）在失败时会返回一个布尔值 false，但不会让整个交易回滚。
如果开发者没有对它进行检查的话，则会发生意外