Solidity中的变量类型

1、值类型(Value Type)：包括布尔型，整数型等等，这类变量赋值时候直接传递数值。
2、引用类型(Reference Type)：包括数组和结构体，这类变量占空间大，赋值时候直接传递地址（类似指针）。
3、映射类型(Mapping Type): Solidity中存储键值对的数据结构，可以理解为哈希表

Solidity语言的函数非常灵活

function <function name>([parameter types[, ...]]) {internal|external|public|private} [pure|view|payable] [virtual|override] [<modifiers>]
[returns (<return types>)]{ <function body> }

function：声明函数时的固定用法。要编写函数，就需要以 function 关键字开头。
<function name>：函数名。
([parameter types[, ...]])：圆括号内写入函数的参数，即输入到函数的变量类型和名称。
{internal|external|public|private}：函数可见性说明符，共有4种。
public：内部和外部均可见。
private：只能从本合约内部访问，继承的合约也不能使用。
external：只能从合约外部访问（但内部可以通过 this.f() 来调用，f是函数名）。
internal: 只能从合约内部访问，继承的合约可以用。
[pure|view|payable]：决定函数权限/功能的关键字。payable（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入 ETH。pure 和 view 的介绍见下一节。
[virtual|override]: 方法是否可以被重写，或者是否是重写方法。virtual用在父合约上，标识的方法可以被子合约重写。override用在子合约上，表名方法重写了父合约的方法。
<modifiers>: 自定义的修饰器，可以有0个或多个修饰器。
[returns ()]：函数返回的变量类型和名称。
<function body>: 函数体。

Solidity 中与函数输出相关的有两个关键字：return和returns。它们的区别在于：
returns：跟在函数名后面，用于声明返回的变量类型及变量名。
return：用于函数主体中，返回指定的变量。

// 返回多个变量
function returnMultiple() public pure returns(uint256, bool, uint256[3] memory){
    return(1, true, [uint256(1),2,5]);
}

Solidity中变量按作用域划分有三种，分别是状态变量（state variable），局部变量（local variable）和全局变量(global variable)

Solidity中两个关键字，constant（常量）和immutable（不变量），让不应该变的变量保持不变。这样的做法能在节省gas的同时提升合约的安全性

继承是面向对象编程很重要的组成部分，可以显著减少重复代码。如果把合约看作是对象的话，Solidity也是面向对象的编程，也支持继承
规则
virtual: 父合约中的函数，如果希望子合约重写，需要加上virtual关键字。
override：子合约重写了父合约中的函数，需要加上override关键字。

接口类似于抽象合约，但它不实现任何功能。接口的规则

不能包含状态变量
不能包含构造函数
不能继承除接口外的其他合约
所有函数都必须是external且不能有函数体
继承接口的非抽象合约必须实现接口定义的所有功能

另外，接口与合约ABI（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的ABI，利用abi-to-sol工具，也可以将ABI json文件转换为接口sol文件

IERC721包含3个事件，其中Transfer和Approval事件在ERC20中也有。

Transfer事件：在转账时被释放，记录代币的发出地址from，接收地址to和tokenId。
Approval事件：在授权时被释放，记录授权地址owner，被授权地址approved和tokenId。
ApprovalForAll事件：在批量授权时被释放，记录批量授权的发出地址owner，被授权地址operator和授权与否的approved。

IERC721函数

balanceOf：返回某地址的NFT持有量balance。
ownerOf：返回某tokenId的主人owner。
transferFrom：普通转账，参数为转出地址from，接收地址to和tokenId。
safeTransferFrom：安全转账（如果接收方是合约地址，会要求实现ERC721Receiver接口）。参数为转出地址from，接收地址to和tokenId。
approve：授权另一个地址使用你的NFT。参数为被授权地址approve和tokenId。
getApproved：查询tokenId被批准给了哪个地址。
setApprovalForAll：将自己持有的该系列NFT批量授权给某个地址operator。
isApprovedForAll：查询某地址的NFT是否批量授权给了另一个operator地址。
safeTransferFrom：安全转账的重载函数，参数里面包含了data。

error方法gas最少，其次是assert，require方法消耗gas最多！因此，error既可以告知用户抛出异常的原因，又能省gas，大家要多用

Solidity中允许函数进行重载（overloading），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，Solidity不允许修饰器（modifier）重载。

库合约是一种特殊的合约，为了提升Solidity代码的复用性和减少gas而存在

Solidity支持两种特殊的回调函数，receive()和fallback()

receive()函数是在合约收到ETH转账时被调用的函数。一个合约最多有一个receive()函数，声明方式与一般函数不一样，不需要function关键字：receive() external payable { ... }。
receive()函数不能有任何的参数，不能返回任何值，必须包含external和payable。

fallback()函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约proxy contract。
fallback()声明时不需要function关键字，必须由external修饰，一般也会用payable修饰，用于接收ETH:fallback() external payable { ... }。

call不是调用合约的推荐方法，因为不安全

什么情况下会用到delegatecall

目前delegatecall主要有两个应用场景：

代理合约（Proxy Contract）：将智能合约的存储合约和逻辑合约分开：代理合约（Proxy Contract）存储所有相关的变量，并且保存逻辑合约的地址；
所有函数存在逻辑合约（Logic Contract）里，通过delegatecall执行。当升级时，只需要将代理合约指向新的逻辑合约即可。
EIP-2535 Diamonds（钻石）：钻石是一个支持构

在以太坊链上，用户（外部账户，EOA）可以创建智能合约，智能合约同样也可以创建新的智能合约。
去中心化交易所uniswap就是利用工厂合约（PairFactory）创建了无数个币对合约（Pair）

selfdestruct命令可以用来删除智能合约，并将该合约剩余ETH转到指定地址

selfdestruct是智能合约的紧急按钮，销毁合约并将剩余ETH转移到指定账户。
当著名的The DAO攻击发生时，以太坊的创始人们一定后悔过没有在合约里加入selfdestruct来停止黑客的攻击吧

ABI (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。
数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。

以太坊中，数据必须编码成字节码才能和智能合约交互

哈希函数（hash function）是一个密码学概念，它可以将任意长度的消息转换为一个固定长度的值，这个值也称作哈希（hash）
一个好的哈希函数应该具有以下几个特点：
单向性：从输入的消息到它的哈希的正向运算简单且唯一确定，而反过来非常难，只能靠暴力枚举。
灵敏性：输入的消息改变一点对它的哈希改变很大。
高效性：从输入的消息到哈希的运算高效。
均一性：每个哈希值被取到的概率应该基本相等。
抗碰撞性：
弱抗碰撞性：给定一个消息x，找到另一个消息x'，使得hash(x) = hash(x')是困难的。
强抗碰撞性：找到任意x和x'，使得hash(x) = hash(x')是困难的。

ERC20是以太坊上的代币标准，来自2015年11月V神参与的EIP20

空投是币圈中一种营销策略，项目方将代币免费发放给特定用户群体。为了拿到空投资格，用户通常需要完成一些简单的任务，如测试产品、分享新闻、介绍朋友等。

EIP全称 Ethereum Improvement Proposals(以太坊改进建议), 是以太坊开发者社区提出的改进建议, 是一系列以编号排定的文件, 类似互联网上IETF的RFC。

EIP可以是 Ethereum 生态中任意领域的改进, 比如新特性、ERC、协议改进、编程工具等等。
ERC全称 Ethereum Request For Comment (以太坊意见征求稿), 用以记录以太坊上应用级的各种开发标准和协议。
如典型的Token标准(ERC20, ERC721)、名字注册(ERC26, ERC13), URI范式(ERC67), Library/Package格式(EIP82), 钱包格式(EIP75,EIP85)。
ERC协议标准是影响以太坊发展的重要因素, 像ERC20, ERC223, ERC721, ERC777等, 都是对以太坊生态产生了很大影响。

所以最终结论：EIP包含ERC。

Merkle Tree，也叫默克尔树或哈希树，是区块链的底层加密技术，被比特币和以太坊区块链广泛采用。Merkle Tree是一种自下而上构建的加密树，每个叶子是对应数据的哈希，而每个非叶子为它的2个子节点的哈希

OpenSea是以太坊上最大的NFT交易平台，总交易总量达到了$300亿。OpenSea在交易中抽成2.5%，因此它通过用户交易至少获利了$7.5亿。另外，它的运作并不去中心化，且不准备发币补偿用户

以太坊EIP1155提出了一个多代币标准ERC1155，允许一个合约包含多个同质化和非同质化代币

WETH (Wrapped ETH)是ETH的带包装版本。我们常见的WETH，WBTC，WBNB，都是带包装的原生代币

分账就是按照一定比例分钱财。在现实中，经常会有“分赃不均”的事情发生；而在区块链的世界里，Code is Law，我们可以事先把每个人应分的比例写在智能合约中，获得收入后，再由智能合约来进行分账。

线性释放指的是代币在归属期内匀速释放

代币锁(Token Locker)是一种简单的时间锁合约，它可以把合约中的代币锁仓一段时间，受益人在锁仓期满后可以取走代币。代币锁一般是用来锁仓流动性提供者LP代币的。

时间锁主要有三个功能：

创建交易，并加入到时间锁队列。
在交易的锁定期满后，执行交易。
后悔了，取消时间锁队列中的某些交易。

代理合约利用delegatecall将函数调用委托给了另一个逻辑合约，使得数据和逻辑分别由不同合约负责。并且，它利用内联汇编黑魔法，让没有返回值的回调函数也可以返回数据

透明代理的逻辑非常简单：管理员可能会因为“函数选择器冲突”，在调用逻辑合约的函数时，误调用代理合约的可升级函数。那么限制管理员的权限，不让他调用任何逻辑合约的函数，就能解决冲突：

多签钱包是一种电子钱包，特点是交易被多个私钥持有者（多签人）授权后才能执行：例如钱包由3个多签人管理，每笔交易需要至少2人签名授权。

ERC20Permit，一个 ERC20 代币标准的拓展，支持用户使用链下签名进行授权操作，改善了用户体验，被很多项目采用。但同时，它也带来了更大的风险，一个签名就能将你的资产卷走

跨链桥是一种区块链协议，它允许在两个或多个区块链之间移动数字资产和信息。
例如，一个在以太坊主网上运行的ERC20代币，可以通过跨链桥转移到其他兼容以太坊的侧链或独立链。

跨链桥，它允许在两个或多个区块链之间移动数字资产和信息，方便用户在多链操作资产。
同时，它也有很大的风险，近两年针对跨链桥的攻击已造成超过20亿美元的用户资产损失

MultiCall（多重调用）合约的设计能让我们在一次交易中执行多个函数调用

恒定乘积自动做市商（Constant Product Automated Market Maker, CPAMM），它是去中心化交易所的核心机制，被Uniswap，PancakeSwap等一系列DEX采用

自动做市商（Automated Market Maker，简称 AMM）是一种算法，或者说是一种在区块链上运行的智能合约，它允许数字资产之间的去中心化交易。
AMM 的引入开创了一种全新的交易方式，无需传统的买家和卖家进行订单匹配，而是通过一种预设的数学公式（比如，常数乘积公式）创建一个流动性池，使得用户可以随时进行交易。

闪电贷，实现基于Uniswap V2，Uniswap V3，和AAVE V3的闪电贷合约，并使用Foundry进行测试

不仅仅ETH转账会触发重入攻击，ERC721和ERC1155的safeTransfer()和safeTransferFrom()安全转账函数，还有ERC777的callback函数，都可能会引发重入攻击

函数选择器很容易被碰撞，即使改变参数类型，依然能构造出具有相同选择器的函数。

管理好合约函数的权限，确保拥有特殊权限的合约的函数不能被用户调用。

智能合约中的权限管理定义了不同角色在应用中的权限

整型溢出漏洞（Arithmetic Over/Under Flows）。这是一个比较经典的漏洞，Solidity 0.8版本后内置了Safemath库，因此很少发生

数字签名可以用于识别数据签名者和验证数据完整性。发送交易时，用户使用私钥签名交易，使得其他人可以验证交易是由相应账户发出的。智能合约也能利用 ECDSA 算法验证用户将在链下创建的签名，然后执行铸造或转账等逻辑

签名重放漏洞三个预防方法
将使用过的签名记录下来，防止二次使用。
将 nonce 和 chainid 包含到签名消息中。
对于由用户输入signature的场景，需要检验signature的长度，确保其长度为65bytes，否则也会产生签名重放问题。

坏随机数漏洞
使用预言机项目提供的链下随机数

在 Web2 中，拒绝服务攻击（DoS）是指通过向服务器发送大量垃圾信息或干扰信息的方式，导致服务器无法向正常用户提供服务的现象。
而在 Web3，它指的是利用漏洞使得智能合约无法正常提供服务。

链上抢跑指的是搜索者或矿工通过调高gas或其他方法将自己的交易安插在其他交易之前，来攫取价值
抢先交易是以太坊等公链上普遍存在的问题。我们没法消除它，但是可以通过减少交易顺序或时间的重要性，减少被抢先交易的收益：
使用预提交方案(commit-reveal scheme)。
使用暗池，用户发出的交易将不进入公开的mempool，而是直接到矿工手里。例如 flashbots 和 TaiChi。
在调用参数中加上保护性参数，如滑点保护，从而减少抢跑者的潜在收益。

智能合约中的tx.origin钓鱼攻击，目前有两种方法可以预防它：
一种是使用msg.sender代替tx.origin；另一种是同时检验tx.origin == msg.sender。
推荐使用第一种方法预防，因为后者会拒绝所有来自其他合约的调用。

未检查低级调用的漏洞
以太坊的低级调用（call, delegatecall, staticcall, send）在失败时会返回一个布尔值 false，但不会让整个交易回滚。
如果开发者没有对它进行检查的话，则会发生意外

智能合约的操纵区块时间攻击，并使用 Foundry 复现了它。
在合并（The Merge）之前，以太坊矿工可以操纵区块时间，如果抽奖合约的伪随机数依赖于区块时间，则可能被攻击。
合并之后，以太坊改为固定 12s 一个区块，并且验证节点不能操纵区块时间。
因此这类攻击不会在以太坊上发生，但仍可能在其他公链中遇到。

预言机操纵的预防方法

不要使用流动性差的池子做价格预言机。
不要使用现货/瞬时价格做价格预言机，要加入价格延迟，例如时间加权平均价格（TWAP）。
使用去中心化的预言机。
使用多个数据源，每次选取最接近价格中位数的几个作为预言机，避免极端情况。
在使用Oracle预言机的询价方法如latestRoundData()，需要对返回结果进行校验，防止使用过时失效数据。
仔细阅读第三方价格预言机的使用文档及参数设置。

NFT的重入攻击漏洞

目前主要有两种预防重入攻击的办法：检查-影响-交互模式（checks-effect-interaction）和重入锁。

Opcodes（操作码）是以太坊智能合约的基本单元。大家写的Solidity智能合约会被编译为字节码（bytecode），然后才能在EVM（以太坊虚拟机）上运行。而字节码就是由一系列Opcodes组成的。
当用户在EVM中调用这个智能合约的函数时，EVM会解析并执行这些Opcodes，以实现合约逻辑。

EVM的基本架构主要包括堆栈，内存，存储，EVM字节码，和燃料费

当一个交易被接收并准备执行时，以太坊会初始化一个新的执行环境并加载合约的字节码。
字节码被翻译成Opcode，被逐一执行。每个Opcodes代表一种操作，比如算术运算、逻辑运算、存储操作或者跳转到其他操作码。
每执行一个Opcodes，都要消耗一定数量的Gas。如果Gas耗尽或者执行出错，执行就会立即停止，所有的状态改变（除了已经消耗的Gas）都会被回滚。
执行完成后，交易的结果会被记录在区块链上，包括Gas的消耗、交易日志等信息。

Opcodes可以根据功能分为以下几类:

堆栈（Stack）指令: 这些指令直接操作EVM堆栈。这包括将元素压入堆栈（如PUSH1）和从堆栈中弹出元素（如POP）。
算术（Arithmetic）指令: 这些指令用于在EVM中执行基本的数学运算，如加法（ADD）、减法（SUB）、乘法（MUL）和除法（DIV）。
比较（Comparison）指令: 这些指令用于比较堆栈顶部的两个元素。例如，大于（GT）和小于（LT）。
位运算（Bitwise）指令: 这些指令用于在位级别上操作数据。例如，按位与（AND）和按位或（OR）。
内存（Memory）指令: 这些指令用于操作EVM的内存。例如，将内存中的数据读取到堆栈（MLOAD）和将堆栈中的数据存储到内存（MSTORE）。
存储（Storage）指令: 这些指令用于操作EVM的账户存储。例如，将存储中的数据读取到堆栈（SLOAD）和将堆栈中的数据保存到存储（SSTORE）。这类指令的gas消耗比内存指令要大。
控制流（Control Flow）指令: 这些指令用于EVM的控制流操作，比如跳转JUMP和跳转目标JUMPDEST。
上下文（Context）指令: 这些指令用于获取交易和区块的上下文信息。例如，获取msg.sender（CALLER）和当前可用的gas（GAS）。

EVM中的程序计数器和堆栈指令，特别是PUSH和POP

基础算术运算的11个指令，包括ADD（加法），MUL（乘法），SUB（减法），和DIV（除法）
比较运算的6个指令，包括LT（小于），GT（大于），和EQ（相等）
位级运算的 8 个指令，包括AND（与），OR（或），和XOR（异或）
内存（Memory）操作的4个指令，包括MSTORE，MSTORE8，MLOAD，和MSIZE
存储（Storage）操作的2个指令：SSTORE和SLOAD
控制流的5个指令，包括STOP，JUMP，JUMPI，JUMPDEST，和PC
查询区块信息的9个指令，包括BLOCKHASH，COINBASE，PREVRANDAO等
DUP是一系列的指令，总共有16个，从DUP1到DUP16，操作码范围为0x80到0x8F，gas消耗均为3
计算数据的哈希是一个常见的操作。以太坊使用Keccak算法（SHA-3）计算数据的哈希，并提供了一个专门的操作码SHA3，Solidity中的keccak256()函数就是建立在它之上的

EVM中与账户（Account）相关的4个指令，包括BALANCE, EXTCODESIZE, EXTCODECOPY, 以及 EXTCODEHASH

每一笔以太坊交易都包含以下属性：
nonce：一个与发送者账户相关的数字，表示该账户已发送的交易数。
gasPrice：交易发送者愿意支付的单位gas价格。
gasLimit：交易发送者为这次交易分配的最大gas数量。
to：交易的接收者地址。当交易为合约创建时，这一字段为空。
value：以wei为单位的发送金额。
data：附带的数据，通常为合约调用的输入数据（calldata）或新合约的初始化代码（initcode）。

EVM的返回数据，通常称为returnData，本质上是一个字节数组。它不遵循固定的数据结构，而是简单地表示为连续的字节。
当合约函数需要返回复杂数据类型（如结构体或数组）时，这些数据将按照ABI规范被编码为字节，并存储在returnData中，供其他函数或合约访问。

EVM中与异常处理相关的2个指令: REVERT 和 INVALID。当它们被触发时，交易会回滚

CALL指令可以被视为以太坊的核心，它允许合约之间进行交互，让区块链上的合约不再孤立。

它从堆栈中弹出7个参数，依次为：

gas：为这次调用分配的gas量。
to：被调用合约的地址。
value：要发送的以太币数量，单位为wei。
mem_in_start：输入数据（calldata）在内存的起始位置。
mem_in_size：输入数据的长度。
mem_out_start：返回数据（returnData）在内存的起始位置。
mem_out_size：返回数据的长度。

DELEGATECALL指令与CALL有许多相似之处，但关键的区别在于调用的上下文不同，它在代理合约和可升级合约中被广泛应用。它的设计目的是允许一个合约借用其他合约的代码，但代码是在原始合约的上下文中执行。这使得一份代码可以被多个合约重复使用，而无需重新部署。
使用DELEGATECALL时msg.sender和msg.value保持不变，修改的存储变量也是原始合约的。

STATICCALL指令，它和CALL指令类似，允许合约执行其他合约的代码，但是不能改变合约状态。它是Solidity中pure和view关键字的基础。

CREATE指令，它可以让合约创建新的合约

传统的CREATE指令通过调用者的地址和nonce来确定新合约的地址，
而CREATE2则提供了一种新的计算方法，使我们可以在合约部署之前预知它的地址。

SELFDESTRUCT指令，它可以让合约自毁。这个指令可能在未来会被弃用，见EIP-4758和EIP-6049。

在EVM中，交易和执行智能合约需要消耗计算资源。为了防止用户恶意的滥用网络资源和补偿验证者所消耗的计算能源，以太坊引入了一种称为Gas的计费机制，使每一笔交易都有一个关联的成本。
在发起交易时，用户设定一个最大Gas数量（gasLimit）和每单位Gas的价格（gasPrice）。如果交易执行超出了gasLimit，交易会回滚，但已消耗的Gas不会退还。

EIP-1677提出了最小代理合约，完全用字节码写成，合约长度仅有55字节，能节省超过90%的gas

因此，最小代理合约的核心元素包括：

使用CALLDATACOPY复制交易的calldata。
使用DELEGATECALL将calldata转发到逻辑合约。
将DELEGATECALL返回的数据复制到内存。
根据DELEGATECALL是否成功来返回结果或回滚交易。